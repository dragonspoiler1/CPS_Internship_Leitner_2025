#!/usr/bin/env pybricks-micropython
from pybricks.hubs import EV3Brick
from pybricks.ev3devices import (Motor, ColorSensor, TouchSensor, UltrasonicSensor)
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.messaging import BluetoothMailboxClient, TextMailbox
from utime import ticks_ms, ticks_diff
from pixy2 import Pixy2

#The Sorter uses multiple Sensors along the ConveyorBelt, it reads and sends its signals to the NetworkHandler
#Further it includes the Elevator/Transporter and sends signals of its current state

def sendLift():
    liftMotor.run_angle(180,1100)
    liftMotor.stop()
    
def returnLift():
    liftMotor.run_angle(180,-1100)
    liftMotor.stop()
    
def sortOut(sorterMotor):
  sorterMotor.run_angle(160,-90)

def returnPosition(sorterMotor):
    sorterMotor.run_angle(160,90)
    
def initialiseMotors():
    liftMotor.run_time(150,1000)

    liftMotor.run_until_stalled(-50, then=Stop.COAST, duty_limit=50)
    
    liftMotor.reset_angle(0)


# initializing Variables 
ev3 = EV3Brick()

sorterMotor = Motor(Port.B)
sorterColorSensor = ColorSensor(Port.S3)
colorToBeFiltered = Color.RED

liftPixycam2 = Pixy2(port=4, i2c_address=0x54)
liftMotor = Motor(Port.A)

#Connnecting to Server
client = BluetoothMailboxClient()
mbox = TextMailbox('SorterManager',client)
client.connect('ev3dev')

ev3.speaker.say("Sorter connected")  

# Create and setup timer support class 
class LiftTimer:
    def __init__(self,timer_ms,pixy2):
        self.trigger_time = None
        self.message_pending = False
        self.timer_ms = timer_ms
        self.pixy2 = pixy2
    
    def check_camera(self):
        
        nr_blocks, blocks = self.pixy2.get_blocks(10, 1)
        
        # Extract data of first (and only) block 
        if (nr_blocks >= 1) and not self.message_pending:
            
            # Options to save informations here
            ev3.speaker.beep()
            
            self.trigger_time = ticks_ms()
            self.message_pending = True
        
        # If we have a pending message and trigger time has passed
        if self.message_pending and ticks_diff(ticks_ms(), self.trigger_time) >= self.timer_ms:
            
            mbox.send('Lift transporting')
            sendLift()
            
            returnLift()
            mbox.send('Lift ready')
            
            
            self.message_pending = False
            print("Message sent via mailbox")          
class SorterTimer:
    def __init__(self,timer_ms):
        self.trigger_time = None
        self.message_pending = False
        self.timer_ms = timer_ms
    
    def check_sorterColorSensor(self):
        # If sensor is pressed and we're not already waiting
        color = sorterColorSensor.color()
            
        if color == colorToBeFiltered and not self.message_pending:
                
            self.trigger_time = ticks_ms()
            self.message_pending = True
            print(color)

            # If we have a pending message and 1 second has passed
        if self.message_pending and ticks_diff(ticks_ms(), self.trigger_time) >= self.timer_ms:
                
            sortOut(sorterMotor)
            returnPosition(sorterMotor)
                
            self.message_pending = False
            print("Message sent via mailbox")
            
# Creating Timer Objects 
liftTimer = LiftTimer(timer_ms=2500,pixy2=liftPixycam2)
sorterTimer = SorterTimer(timer_ms=1500)



# Initialize Motors 
initialiseMotors()
ev3.screen.print("Initialisation complete")
mbox.send("Initialisation complete")


while True:
    sorterTimer.check_sorterColorSensor()
    liftTimer.check_camera()

    if not (mbox.read() == colorToBeFiltered):
        colorToBeFiltered = mbox.read()
        
    wait(10)
