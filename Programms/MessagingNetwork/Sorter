#!/usr/bin/env pybricks-micropython

from pybricks.hubs import EV3Brick
from pybricks.ev3devices import (Motor, ColorSensor, TouchSensor, UltrasonicSensor)
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.messaging import BluetoothMailboxClient, TextMailbox
from utime import ticks_ms, ticks_diff


#The Sorter uses multiple Sensors along the ConveyorBelt, it reads and sends its signals to the NetworkHandler
#Further it includes the Elevator/Transporter and sends signals of its current state

def sendLift():
    liftMotor.run_angle(180,1100)
    liftMotor.stop()
    
def returnLift():
    liftMotor.run_angle(180,-1100)
    liftMotor.stop()
    
def sortOut(sorterMotor):
  sorterMotor.run_angle(160,-90)

def returnPosition(sorterMotor):
    sorterMotor.run_angle(160,90)
    
def initialiseMotors():
    liftMotor.run_time(150,1000)

    while liftTouchSensor.pressed() == False:
        liftMotor.run(-50)
    
    liftMotor.reset_angle(0)

    

# initializing Variables 
ev3 = EV3Brick()

sorterMotor = Motor(Port.B)
sorterColorSensor = ColorSensor(Port.S3)
colorToBeFiltered = Color.BLUE

liftsonicSensor = UltrasonicSensor(Port.S2)
liftMotor = Motor(Port.A)
liftTouchSensor = TouchSensor(Port.S1)

#Connnecting to Server
client = BluetoothMailboxClient()
mbox = TextMailbox('SorterManager',client)
client.connect('ev3dev')

ev3.speaker.say("Sorter connected")  

# Create and setup timer support class 
class LiftTimer:
    def __init__(self,timer_ms):
        self.trigger_time = None
        self.message_pending = False
        self.timer_ms = timer_ms
    
    def check_Sonicsensor(self):
        # If sensor is pressed and we're not already waiting
        
        if (liftsonicSensor.distance() > 46+3 or liftsonicSensor.distance() < 46-3) and not self.message_pending:
            print(liftsonicSensor.distance())
            self.trigger_time = ticks_ms()
            self.message_pending = True
            print("Activity detected - waiting")
        
        # If we have a pending message and trigger time has passed
        if self.message_pending and ticks_diff(ticks_ms(), self.trigger_time) >= self.timer_ms:
            
            mbox.send('Lift transporting')
            sendLift()
            
            returnLift()
            mbox.send('Lift ready')
            
            
            self.message_pending = False
            print("Message sent via mailbox")
            
            
class SorterTimer:
    def __init__(self,timer_ms):
        self.trigger_time = None
        self.message_pending = False
        self.timer_ms = timer_ms
    
    def check_sorterColorSensor(self):
        # If sensor is pressed and we're not already waiting
        if sorterColorSensor.color() == colorToBeFiltered and not self.message_pending:
            self.trigger_time = ticks_ms()
            self.message_pending = True
            ev3.screen.print("Activity detected - waiting 1 second")
        
        # If we have a pending message and 1 second has passed
        if self.message_pending and ticks_diff(ticks_ms(), self.trigger_time) >= self.timer_ms:
            
            sortOut(sorterMotor)
            returnPosition(sorterMotor)
            
            self.message_pending = False
            print("Message sent via mailbox")
            

# Creating Timer Objects 
liftTimer = LiftTimer(timer_ms=1000)
sorterTimer = SorterTimer(timer_ms=1500)

# Initialize Motors 
initialiseMotors()
mbox.send("Initialisation complete")


while True:
    sorterTimer.check_sorterColorSensor()
    liftTimer.check_Sonicsensor()
    if not (mbox.read() == colorToBeFiltered):
        colorToBeFiltered = mbox.read()
        
    wait(10)
